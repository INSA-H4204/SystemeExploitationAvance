#include "new_sched.h"
#include "phyAlloc.h"
#include "hw.h"
#define NULL 0
#define COMPARE(a, b) ((a) >= (b))

struct ctx_s* current_ctx;
struct pcb_s * pcb_main = NULL;
struct pcb_s * pcb_head = NULL;
struct pcb_s * pcb_tail = NULL;
struct pcb_s * current_process = NULL;
struct heap * pri_queue = NULL;

static const unsigned int base_size = 4;

/*
*	Should be fine
*/
void init_ctx(struct ctx_s* ctx, func_t f, unsigned int stack_size) {
	
	ctx->sp = (uint32*)phyAlloc_alloc(stack_size);//Allocation de stack_size place mémoire, sp pointe vers la première case mémoire
	ctx->sp += stack_size;//Déplacement du stack pointer de stack_size cases mémoires -> On pointe désormais une case au dessus de la pile
	ctx->sp -= 1;//On pointe désormais sur la derniere case mémoire allouée

	*(ctx->sp) = 0x53;
	ctx->sp --;
	*(ctx->sp) = start_current_process;

	ctx->sp -= 13;//On laisse 13 places pour 13 registres
	ctx->lr = (uint32*)f;
}

/*
*	Should be fine
*/
void init_pcb(struct pcb_s* pcb, func_t f, unsigned int stack_size,unsigned int priority, unsigned int waiting_time) {
	pcb->ctx = phyAlloc_alloc(sizeof(struct ctx_s));
	init_ctx(pcb->ctx,&start_current_process,stack_size);
	pcb->state = READY;
	pcb->f = f;
	pcb->priority = priority;
	pcb->waiting_time = waiting_time;
}

void create_process(func_t f, void* args, unsigned int stack_size,unsigned int priority, unsigned int waiting_time) {
	DISABLE_IRQ();
	//New PCB allocation
	struct pcb_s* pcb = phyAlloc_alloc(sizeof(struct pcb_s));
	//Add pcb to PCB chained list
	//Initialize PCB
	init_pcb(pcb,f,stack_size,priority, waiting_time);
	heap_push(pri_queue, pcb);
	set_tick_and_enable_timer();
	ENABLE_IRQ();
}

void start_current_process() {
	//Lancer un processus.
	//current_process->state = ACTIVE;
	current_process->f();
	current_process->state = TERMINATED;
	ctx_switch();
}
	

void elect() {
// fait pointer la variable globale current_process sur son PCB.
	//struct pcb_s * terminated_process = NULL;
	/*while(current_process->next->state == TERMINATED) {
		terminated_process = current_process->next;
		current_process->next=(current_process->next)->next;
		if(current_process == current_process->next) {
			current_process = pcb_main;
			current_process->next = pcb_main;
		}
		terminated_process->ctx->sp -= 512 + 14;
		phyAlloc_free(terminated_process->ctx->sp, 512);
		phyAlloc_free(terminated_process->ctx, sizeof(struct ctx_s));
		phyAlloc_free(terminated_process, sizeof(struct pcb_s));
	}*/
	if(current_process->next->state == TERMINATED) {
		phyAlloc_free(current_process->ctx->sp, 512);
		phyAlloc_free(current_process->ctx, sizeof(struct ctx_s));
		phyAlloc_free(current_process, sizeof(struct pcb_s));
		heap_pop(pri_queue);
	} else {
		current_process->waiting_time = 0;
		heap_push(pri_queue, current_process);
		heap_pop(pri_queue);
	}
}

void start_sched() {
	pcb_main = phyAlloc_alloc(sizeof(struct pcb_s));
	init_pcb(pcb_main, NULL, 512,1,1);
	//pcb_main->next = pcb_head;
	current_process = pcb_main;
	heap_push(pri_queue, current_process);
	set_tick_and_enable_timer();	
	ENABLE_IRQ();
}


/*void __attribute__ ((naked)) switch_to(struct ctx_s* ctx) {
	__asm("push {r0-r12}");
	//Save current context
	__asm("mov %0, lr" : "=r"(current_ctx->lr));
	__asm("mov %0, sp" : "=r"(current_ctx->sp));
	//Change current context
	current_ctx = ctx;
	//Restore new context
	__asm("mov sp, %0" : : "r"(ctx->sp));
	__asm("mov lr, %0" : : "r"(ctx->lr));
	//Jump to restored context current adress
	__asm("pop {r0-r12}");
	__asm("bx lr");
}
*/

/*
*	Should be fine
*/
void __attribute__ ((naked)) ctx_switch() {
	
	DISABLE_IRQ();
	
	//sauvegarde le contexte du processus en cours d’exécution
	__asm("push {r0-r12}");
	__asm("mov %0, lr" : "=r"(current_process->ctx->lr));
	__asm("mov %0, sp" : "=r"(current_process->ctx->sp));	
	//demande au scheduler d’élire un nouveau processus
	elect();
	//restaure le contexte du processus élu
	__asm("mov sp, %0" : : "r"(current_process->ctx->sp));
	__asm("mov lr, %0" : : "r"(current_process->ctx->lr));
	//Jump to restored context current adress
	set_tick_and_enable_timer();
	__asm("pop {r0-r12}");
	ENABLE_IRQ();
	__asm("bx lr");
}



/*
*	Should be fine
*/
void __attribute__ ((naked)) ctx_switch_from_irq() {

	DISABLE_IRQ();

	__asm("sub lr, lr, #4");
	__asm("srsdb sp!, #0x13");
	__asm("cps #0x13");
	//sauvegarde le contexte du processus en cours d’exécution
	__asm("push {r0-r12}");
	__asm("mov %0, lr" : "=r"(current_process->ctx->lr));
	__asm("mov %0, sp" : "=r"(current_process->ctx->sp));
	current_process->state = READY;
	elect();
	current_process->state = ACTIVE;
	//restaure le contexte du processus élu
	__asm("mov sp, %0" : : "r"(current_process->ctx->sp));
	__asm("mov lr, %0" : : "r"(current_process->ctx->lr));
	set_tick_and_enable_timer_priority(current_process->priority);	
	__asm("pop {r0-r12}");
	ENABLE_IRQ();
	__asm("rfeia sp!");
}






void heap_init()
{
	pri_queue = &(struct heap){
		.size = base_size,
		.count = 0,
		.data = (struct pcb_s*) phyAlloc_alloc(sizeof(struct pcb_s) * base_size)
	};
}

void heap_push(struct heap *h, struct pcb_s* value)
{
	unsigned int index, parent;
 
	if (h->count == h->size)
	{
		h->size <<= 1;
		struct pcb_s* temp = phyAlloc_alloc(h->size * base_size);
		int i;
		for(i=0; i<h->count; i++) {
			temp[i] = h->data[i];
		}
		phyAlloc_free(h->data, (h->size * base_size)/2);
		h->data = temp;
	} 

	for(index = h->count++; index; index = parent)
	{
		parent = (index - 1) >> 1;
		if COMPARE((h->data[parent].priority)*(h->data[parent].waiting_time), (value->priority*value->waiting_time)) break;
		h->data[index] = h->data[parent];
	}
	h->data[index] = *value; 
}




void heap_pop(struct heap *h)
{
	unsigned int index, swap, other;
 
	struct pcb_s popped_element = h->data[--h->count];
 
	if ((h->count <= (h->size >> 2)) && (h->size > base_size))
	{
		h->size >>= 1;
		struct pcb_s* temp = phyAlloc_alloc(h->size * base_size);
		int i;
		for(i=0; i<h->count; i++) {
			temp[i] = h->data[i];
			temp[i].waiting_time++;
		}
		phyAlloc_free(h->data, (h->size * base_size)*2);
		h->data = temp;
	}
 
	for(index = 0; 1; index = swap)
	{
		swap = (index << 1) + 1;
		if (swap >= h->count) break;
		other = swap + 1;
		if ((other < h->count) && COMPARE(h->data[other].priority, h->data[swap].priority)) swap = other;
		if COMPARE((popped_element.priority)*(popped_element.waiting_time), (h->data[swap].priority)*(h->data[swap].waiting_time)) break;
 
		h->data[index] = h->data[swap];
	}
	h->data[index] = popped_element;

	current_process =  &popped_element;
}
