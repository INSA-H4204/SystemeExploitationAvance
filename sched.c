#include "sched.h"
#include "phyAlloc.h"
#include "hw.h"
#define NULL 0

struct ctx_s* current_ctx;
struct pcb_s * pcb_main = NULL;
struct pcb_s * pcb_head = NULL;
struct pcb_s * pcb_tail = NULL;
struct pcb_s * current_process = NULL;

void init_ctx(struct ctx_s* ctx, func_t f, unsigned int stack_size) {
	
	ctx->sp = (uint32*)phyAlloc_alloc(stack_size);//Allocation de stack_size place mémoire, sp pointe vers la première case mémoire
	ctx->sp += stack_size;//Déplacement du stack pointer de stack_size cases mémoires -> On pointe désormais une case au dessus de la pile
	ctx->sp -= 1;//On pointe désormais sur la derniere case mémoire allouée

	*(ctx->sp) = 0x53;
	ctx->sp --;
	*(ctx->sp) = start_current_process;

	ctx->sp -= 13;//On laisse 13 places pour 13 registres
	ctx->lr = (uint32*)f;
}

void init_pcb(struct pcb_s* pcb, func_t f, unsigned int stack_size,unsigned int priority) {
	pcb->ctx = phyAlloc_alloc(sizeof(struct ctx_s));
	init_ctx(pcb->ctx,&start_current_process,stack_size);
	pcb->state = READY;
	pcb->f = f;
	pcb->priority = priority;
}


void create_process(func_t f, void* args, unsigned int stack_size,unsigned int priority) {
	DISABLE_IRQ();
	//New PCB allocation
	struct pcb_s* pcb = phyAlloc_alloc(sizeof(struct pcb_s));
	//Add pcb to PCB chained list
	if (pcb_tail == NULL && pcb_head == NULL) {
		pcb_tail = pcb;
		pcb_head = pcb;
		pcb->next = pcb;	
	}
	else {
		pcb_tail->next = pcb;
		pcb_tail = pcb;
		pcb_tail->next = pcb_head;
	}
	//Initialize PCB
	init_pcb(pcb,f,stack_size,priority);
	set_tick_and_enable_timer();
	ENABLE_IRQ();
}

void start_current_process() {
	//Lancer un processus.
	//current_process->state = ACTIVE;
	current_process->f();
	current_process->state = TERMINATED;
	ctx_switch();
}
	

void elect() {
// fait pointer la variable globale current_process sur son PCB.
	struct pcb_s * terminated_process = NULL;
	while(current_process->next->state == TERMINATED) {
		terminated_process = current_process->next;
		current_process->next=(current_process->next)->next;
		if(current_process == current_process->next) {
			current_process = pcb_main;
			current_process->next = pcb_main;
		}
		terminated_process->ctx->sp -= 512 + 14;
		phyAlloc_free(terminated_process->ctx->sp, 512);
		phyAlloc_free(terminated_process->ctx, sizeof(struct ctx_s));
		phyAlloc_free(terminated_process, sizeof(struct pcb_s));
	}
	if (current_process->next != pcb_main)
		current_process = current_process->next;
}

void start_sched() {
	pcb_main = phyAlloc_alloc(sizeof(struct pcb_s));
	init_pcb(pcb_main, NULL, 512,1);
	pcb_main->next = pcb_head;
	current_process = pcb_main;
	set_tick_and_enable_timer_priority(pcb_main->priority);	
	ENABLE_IRQ();
}


/*void __attribute__ ((naked)) switch_to(struct ctx_s* ctx) {
	__asm("push {r0-r12}");
	//Save current context
	__asm("mov %0, lr" : "=r"(current_ctx->lr));
	__asm("mov %0, sp" : "=r"(current_ctx->sp));
	//Change current context
	current_ctx = ctx;
	//Restore new context
	__asm("mov sp, %0" : : "r"(ctx->sp));
	__asm("mov lr, %0" : : "r"(ctx->lr));
	//Jump to restored context current adress
	__asm("pop {r0-r12}");
	__asm("bx lr");
}
*/

void __attribute__ ((naked)) ctx_switch() {
	
	DISABLE_IRQ();
	
	//sauvegarde le contexte du processus en cours d’exécution
	__asm("push {r0-r12}");
	__asm("mov %0, lr" : "=r"(current_process->ctx->lr));
	__asm("mov %0, sp" : "=r"(current_process->ctx->sp));	
	//demande au scheduler d’élire un nouveau processus
	elect();
	//restaure le contexte du processus élu
	__asm("mov sp, %0" : : "r"(current_process->ctx->sp));
	__asm("mov lr, %0" : : "r"(current_process->ctx->lr));
	//Jump to restored context current adress
	set_tick_and_enable_timer();
	__asm("pop {r0-r12}");
	ENABLE_IRQ();
	__asm("bx lr");
}


void __attribute__ ((naked)) ctx_switch_from_irq() {

	DISABLE_IRQ();

	__asm("sub lr, lr, #4");
	__asm("srsdb sp!, #0x13");
	__asm("cps #0x13");
	//sauvegarde le contexte du processus en cours d’exécution
	__asm("push {r0-r12}");
	__asm("mov %0, lr" : "=r"(current_process->ctx->lr));
	__asm("mov %0, sp" : "=r"(current_process->ctx->sp));
	current_process->state = READY;
	elect();
	current_process->state = ACTIVE;
	//restaure le contexte du processus élu
	__asm("mov sp, %0" : : "r"(current_process->ctx->sp));
	__asm("mov lr, %0" : : "r"(current_process->ctx->lr));
	set_tick_and_enable_timer_priority(current_process->priority);	
	__asm("pop {r0-r12}");
	ENABLE_IRQ();
	__asm("rfeia sp!");

}
